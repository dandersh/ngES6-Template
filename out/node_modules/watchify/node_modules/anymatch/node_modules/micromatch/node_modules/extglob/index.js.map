{"version":3,"sources":["../../../../../../../../../node_modules/watchify/node_modules/anymatch/node_modules/micromatch/node_modules/extglob/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/*!\n * extglob <https://github.com/jonschlinkert/extglob>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Module dependencies\n */\n\nvar isExtglob = require('is-extglob');\nvar re, cache = {};\n\n/**\n * Expose `extglob`\n */\n\nmodule.exports = extglob;\n\n/**\n * Convert the given extglob `string` to a regex-compatible\n * string.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob('!(a?(b))');\n * //=> '(?!a(?:b)?)[^/]*?'\n * ```\n *\n * @param {String} `str` The string to convert.\n * @param {Object} `options`\n *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.\n *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.\n * @return {String}\n * @api public\n */\n\n\nfunction extglob(str, opts) {\n  opts = opts || {};\n  var o = {}, i = 0;\n\n  // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!(');\n\n  // support file extension negation\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n    return escape('[^.]+');\n  });\n\n  // create a unique key for caching by\n  // combining the string and options\n  var key = str\n    + String(!!opts.regex)\n    + String(!!opts.contains)\n    + String(!!opts.escape);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n\n  opts.negate = false;\n  var m;\n\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n\n    var id = '__EXTGLOB_' + (i++) + '__';\n    // use the prefix of the _last_ (outtermost) pattern\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n\n  var keys = Object.keys(o);\n  var len = keys.length;\n\n  // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n\n  var result = opts.regex\n    ? toRegex(str, opts.contains, opts.negate)\n    : str;\n\n  result = result.split('.').join('\\\\.');\n\n  // cache the result and return it\n  return (cache[key] = result);\n}\n\n/**\n * Convert `string` to a regex string.\n *\n * @param  {String} `str`\n * @param  {String} `prefix` Character that determines how to wrap the string.\n * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.\n * @return {String}\n */\n\nfunction wrap(inner, prefix, esc) {\n  if (esc) inner = escape(inner);\n\n  switch (prefix) {\n    case '!':\n      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');\n    case '@':\n      return '(?:' + inner + ')';\n    case '+':\n      return '(?:' + inner + ')+';\n    case '*':\n      return '(?:' + inner + ')' + (esc ? '%%' : '*')\n    case '?':\n      return '(?:' + inner + '|)';\n    default:\n      return inner;\n  }\n}\n\nfunction escape(str) {\n  str = str.split('*').join('[^/]%%%~');\n  str = str.split('.').join('\\\\.');\n  return str;\n}\n\n/**\n * extglob regex.\n */\n\nfunction regex() {\n  return /(\\\\?[@?!+*$]\\\\?)(\\(([^()]*?)\\))/;\n}\n\n/**\n * Negation regex\n */\n\nfunction negate(str) {\n  return '(?!^' + str + ').*$';\n}\n\n/**\n * Create the regex to do the matching. If\n * the leading character in the `pattern` is `!`\n * a negation regex is returned.\n *\n * @param {String} `pattern`\n * @param {Boolean} `contains` Allow loose matching.\n * @param {Boolean} `isNegated` True if the pattern is a negation pattern.\n */\n\nfunction toRegex(pattern, contains, isNegated) {\n  var prefix = contains ? '^' : '';\n  var after = contains ? '$' : '';\n  pattern = ('(?:' + pattern + ')' + after);\n  if (isNegated) {\n    pattern = prefix + negate(pattern);\n  }\n  return new RegExp(prefix + pattern);\n}\n"]}