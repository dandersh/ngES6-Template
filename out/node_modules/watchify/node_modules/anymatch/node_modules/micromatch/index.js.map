{"version":3,"sources":["../../../../../../../node_modules/watchify/node_modules/anymatch/node_modules/micromatch/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar expand = require('./lib/expand');\nvar utils = require('./lib/utils');\n\n/**\n * The main function. Pass an array of filepaths,\n * and a string or array of glob patterns\n *\n * @param  {Array|String} `files`\n * @param  {Array|String} `patterns`\n * @param  {Object} `opts`\n * @return {Array} Array of matches\n */\n\nfunction micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n\n  var len = patterns.length, i = 0;\n  var omit = [], keep = [];\n\n  while (len--) {\n    var glob = patterns[i++];\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, match(files, glob.slice(1), opts));\n    } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n  return utils.diff(keep, omit);\n}\n\n/**\n * Return an array of files that match the given glob pattern.\n *\n * This function is called by the main `micromatch` function If you only\n * need to pass a single pattern you might get very minor speed improvements\n * using this function.\n *\n * @param  {Array} `files`\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Array}\n */\n\nfunction match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n    if (negate) {\n      pattern = pattern.slice(1);\n    }\n\n    // we need to remove the character regardless,\n    // so the above logic is still needed\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n  var len = files.length, i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) { continue; }\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  }\n\n  // if `negate` was defined, diff negated files\n  if (negate) { res = utils.diff(files, res); }\n\n  // if `ignore` was defined, diff ignored filed\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n  return res;\n}\n\n/**\n * Returns a function that takes a glob pattern or array of glob patterns\n * to be used with `Array#filter()`. (Internally this function generates\n * the matching function using the [matcher] method).\n *\n * ```js\n * var fn = mm.filter('[a-c]');\n * ['a', 'b', 'c', 'd', 'e'].filter(fn);\n * //=> ['a', 'b', 'c']\n * ```\n * @param  {String|Array} `patterns` Can be a glob or array of globs.\n * @param  {Options} `opts` Options to pass to the [matcher] method.\n * @return {Function} Filter function to be passed to `Array#filter()`.\n */\n\nfunction filter(patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('filter', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length, i = 0;\n  var patternMatchers = Array(len);\n  while (i < len) {\n    patternMatchers[i] = matcher(patterns[i++], opts);\n  }\n\n  return function(fp) {\n    if (fp == null) return [];\n    var len = patternMatchers.length, i = 0;\n    var res = true;\n\n    fp = utils.unixify(fp, opts);\n    while (i < len) {\n      var fn = patternMatchers[i++];\n      if (!fn(fp)) {\n        res = false;\n        break;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns true if the filepath contains the given\n * pattern. Can also return a function for matching.\n *\n * ```js\n * isMatch('foo.md', '*.md', {});\n * //=> true\n *\n * isMatch('*.md', {})('foo.md')\n * //=> true\n * ```\n * @param  {String} `fp`\n * @param  {String} `pattern`\n * @param  {Object} `opts`\n * @return {Boolean}\n */\n\nfunction isMatch(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('isMatch', 'filepath', 'a string'));\n  }\n\n  fp = utils.unixify(fp, opts);\n  if (utils.typeOf(pattern) === 'object') {\n    return matcher(fp, pattern);\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if the filepath matches the\n * given pattern.\n */\n\nfunction contains(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('contains', 'pattern', 'a string'));\n  }\n\n  opts = opts || {};\n  opts.contains = (pattern !== '');\n  fp = utils.unixify(fp, opts);\n\n  if (opts.contains && !utils.isGlob(pattern)) {\n    return fp.indexOf(pattern) !== -1;\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if a file path matches any of the\n * given patterns.\n *\n * @param  {String} `fp` The filepath to test.\n * @param  {String|Array} `patterns` Glob patterns to use.\n * @param  {Object} `opts` Options to pass to the `matcher()` function.\n * @return {String}\n */\n\nfunction any(fp, patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('any', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length;\n\n  fp = utils.unixify(fp, opts);\n  while (len--) {\n    var isMatch = matcher(patterns[len], opts);\n    if (isMatch(fp)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Filter the keys of an object with the given `glob` pattern\n * and `options`\n *\n * @param  {Object} `object`\n * @param  {Pattern} `object`\n * @return {Array}\n */\n\nfunction matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n}\n\n/**\n * Return a function for matching based on the\n * given `pattern` and `options`.\n *\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Function}\n */\n\nfunction matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  }\n  // pattern is a regex\n  if (pattern instanceof RegExp) {\n    return function(fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  }\n\n  // strings, all the way down...\n  pattern = utils.unixify(pattern, opts);\n\n  // pattern is a non-glob string\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  }\n  // pattern is a glob string\n  var re = makeRe(pattern, opts);\n\n  // `matchBase` is defined\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  }\n  // `matchBase` is not defined\n  return function(fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}\n\n/**\n * Create and cache a regular expression for matching\n * file paths.\n *\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction toRegex(glob, options) {\n  // clone options to prevent  mutating the original object\n  var opts = Object.create(options || {});\n  var flags = opts.flags || '';\n  if (opts.nocase && flags.indexOf('i') === -1) {\n    flags += 'i';\n  }\n\n  var parsed = expand(glob, opts);\n\n  // pass in tokens to avoid parsing more than once\n  opts.negated = opts.negated || parsed.negated;\n  opts.negate = opts.negated;\n  glob = wrapGlob(parsed.pattern, opts);\n  var re;\n\n  try {\n    re = new RegExp(glob, flags);\n    return re;\n  } catch (err) {\n    err.reason = 'micromatch invalid regex: (' + re + ')';\n    if (opts.strict) throw new SyntaxError(err);\n  }\n\n  // we're only here if a bad pattern was used and the user\n  // passed `options.silent`, so match nothing\n  return /$^/;\n}\n\n/**\n * Create the regex to do the matching. If the leading\n * character in the `glob` is `!` a negation regex is returned.\n *\n * @param {String} `glob`\n * @param {Boolean} `negate`\n */\n\nfunction wrapGlob(glob, opts) {\n  var prefix = (opts && !opts.contains) ? '^' : '';\n  var after = (opts && !opts.contains) ? '$' : '';\n  glob = ('(?:' + glob + ')' + after);\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n  return prefix + glob;\n}\n\n/**\n * Create and cache a regular expression for matching file paths.\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction makeRe(glob, opts) {\n  if (utils.typeOf(glob) !== 'string') {\n    throw new Error(msg('makeRe', 'glob', 'a string'));\n  }\n  return utils.cache(toRegex, glob, opts);\n}\n\n/**\n * Make error messages consistent. Follows this format:\n *\n * ```js\n * msg(methodName, argNumber, nativeType);\n * // example:\n * msg('matchKeys', 'first', 'an object');\n * ```\n *\n * @param  {String} `method`\n * @param  {String} `num`\n * @param  {String} `type`\n * @return {String}\n */\n\nfunction msg(method, what, type) {\n  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';\n}\n\n/**\n * Public methods\n */\n\n/* eslint no-multi-spaces: 0 */\nmicromatch.any       = any;\nmicromatch.braces    = micromatch.braceExpand = utils.braces;\nmicromatch.contains  = contains;\nmicromatch.expand    = expand;\nmicromatch.filter    = filter;\nmicromatch.isMatch   = isMatch;\nmicromatch.makeRe    = makeRe;\nmicromatch.match     = match;\nmicromatch.matcher   = matcher;\nmicromatch.matchKeys = matchKeys;\n\n/**\n * Expose `micromatch`\n */\n\nmodule.exports = micromatch;\n"]}